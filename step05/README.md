## Шаг 5. Строим сторадж
У нас есть LRU хранилище. Нам нужно решить две задачи на этом шаге:

1. Сделать хранилище консистентным
2. Придумать ему архитектуру


Напомню, нам нужно хранить следующие данные
```Go
type (
  Location struct {
    Lat float64
    Lon float64
  }
  Driver struct {
    ID int 
    LastLocation Location
    Locations *lru.LRU
  }
)
```
Так и запишем их в `storage/storage.go`

Напомню, что нам нужно реализовать следующие фичи:

1. New(size) - для инциализации стораджа
2. Set(key, value) - для добавления или обновления элемента
3. Delete(key) - для удаления
4. Nearest() - для получения блищайших элементов
5. Get(key) - для получения водителя

Из формулировки задачи мы выбрали `R-tree` для реализации быстрой работы `Nearest()` метода. Его мы возьмем [отсюда](https://github.com/dhconnelly/rtreego)

Вырисовывается следующая структура для хранения
```Go
type DriverStorage struct {
  mu *sync.RWMutex
  drivers map[int]*Driver
  locations *rtreego.Rtree
  lruSize int
}
```

В этой структуре нам нужны:

1. sync.RWMutex для того, чтобы данные у нас были консистентны
2. drivers - для хранения всех водителей
3. locations - для того, чтобы возвращать блишайших к нам водителей

## Поздравляю! 
Мы сделали архитектуру для нашего хранилища. Разобрались как сделать консистентность данных. Реализовывать его будем в [следующем](../step06/README.md) уроке
